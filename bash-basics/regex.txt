https://www.youtube.com/watch?v=FF4QlndOO8s

sed/grep:
---------------------------------------

cal | grep 0
cal | grep .

grep . <<@@@ - это hear document (ввод документа с клавиатуры пока не встретится конец строки @@@)
grep q <<<bfqiwfqwfbqwfbiqw - это hear string

grep '[a-f]' <<<bfqiwfqwfbqwfbiqw - заключаем в апострофы иначе это шельный шаблон для генерации имен файлов
grep '[^a-f]' <<<bfqiwfqwfbqwfbiqw - отрицание диапазона, все символы не входящие в это множество


повторители:
* повторение 0 или больше раз
+ повторение 1 или больше раз
? 0 или 1 раз (не приводит к разростанию строки)
{3,5} - диапазон

правило - самый левый самый длинный. 
			"A.*B.*A" ? wAtBlaBlAs
			12 34 5     12   345
			"(cd|ab)+$" ? sabcadababcd
			  1  2             2 2 1
(a(b(c(d)*)*)*)* - работает очень долго, не надо делать вложенные повторители


egrep --color '([as][zx])*' <<<asfdfaazazsasfaxasdfas
повторитель * жадный он стремится захватить как можно больше, но он начинается с нуля

sed -E 's/([as][zx])*/@@@/' <<<asfdfaazazsasfaxasdfas - добавляет @@@ в начало т.к. * начинается от 0
sed -E 's/([as][zx])+/@@@/' <<<asfdfaazazsasfaxasdfas - заменяет 1ый azaz
sed --regexp-extended 's/([as][zx])+/@@@/' <<<asfdfaazazsasfaxasdfas - оно же

Подстановки:
sed --regexp-extended -- 's/Z(([ab][cd])*)Z/@@@\0@@@/' <<<ooooZacacadbdZooooooooo
sed --regexp-extended -- 's/Z(([ab][cd])*)Z/@@@\1@@@/' <<<ooooZacacadbdZooooooooo
sed --regexp-extended -- 's/Z(([ab][cd])*)Z/@@@\2@@@/' <<<ooooZacacadbdZooooooooo
Номер группы это просто номер скобочки, содержимое скобочки то то что туда заматчилось в последний раз

Позиционирование подстроки в строке:
grep '[a-f]*' <<<afsarvervdfklavbsakhvbsa
grep '^[a-f]*' <<<afsarvervdfklavbsakhvbsa
grep '[a-f]*$' <<<afsarvervdfklavbsakhvbsa


. любой символ
\ -экранирует символ
| - ИЛИ, альтернатива

Повторитель который мачится на пустую строку это зло :)
egrep '(as)*' <<<afsarvervdfklavbsakhvbsa


основные рег. выр.: 
grep метасимволы вроде: ‘{‘, ‘}’, ‘(‘, ‘)’, ‘|’, ‘+’, ‘?’ теряют свой смысл и считаются нормальными символами
строки и должны быть выделены специальным образом, если их следует рассматривать как специальные символы.
расширенные рег. выр.:
egrep Эта версия grep эффективна и быстра, когда дело доходит до поиска шаблона регулярных выражений, 
поскольку она обрабатывает метасимволы как есть и не заменяет их как строки. 

grep '(as)*' <<<"(as))))))fsarvervdfklavbsakhvbsa"

grep -F или fgrep просто ищет строку оно не распознает ни регулярные выражения, ни метасимволы.



Классы эквивалентности:
egrep '[[:digit:]]+' <<<c34ccb234biun235
egrep '[[:alnum:]]+' <<<c34ccb234biun235
egrep '[[:space:]]+' <<<'c34ccb23 4biun 235'


!!! на самом деле расширенные регулярные выражения порождают тот е класс зыков что и обычные. 
Любая конструкция в расширенном языке может быть реализована с помощью обычных регулярных выражений,
но более громоздко.



Утилита tr это sed "для бедных" маленький маленький sed
cal | tr -d ' '
cal | tr ' ' '.'

man и less замечательно ищут по регулярным выражениям
vim тоже может поиск и замену регулярного выражения

В "толстых" языках программирования Perl(PCRE),Python,PHP используются регулярные выражения, 
которые регулярными не являются, т.е. они выводят нас за класс регулярных грамматик

Регулярным выражением нельзя замачить:
- поискать что-то в тексте, а потом поискать еще раз или несколько раз cal | egrep '(.)2.*\1' 
	backreference это выход за регулярные выражения
- Python: look ahead {?=...}, look behind {?<=...}
- нежадные повторители (выдает самый короткий вариант из возможных), бывают оч. медленные

Читать mre (книга orelly)






--------------------------------
sed:

cat file | sed -r '' - печатает файл
cat file | sed -r -n '' - тихий режим не печатает файл
cat file | sed -r '3,5d' - удаляет строки 3-5
cat file | sed -r -n '3,5p' - тихий режим, печатает строки 3-5
cat file | sed -r '/Adwords/d' - удяляет строки содержащие регулярное выражение
cat file | sed -r -n '/Adwords/p' - печатает строки сожержащие регулярное выражение

cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r 's/Adwords/***/' - замена, происходит по строкам только для первого появления
cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r 's/Adwords/***/g' - глобальная замена во всей строке
cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r 's/Adwords/***/gi' - не чувствительная к регистру

cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r 's/Adwords//' - удаление
cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r '2,3 s/Adwords/***/g' - глобальная замена в строках с 2 до 3
cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r '2,+3 s/Adwords/***/g' - глобальная замена со стр2 + еще 3 строки
cat log_maintable_msk.log  | sed -r -n '/Adwords/p' | sed -r '2,$ s/Adwords/***/g' - глобальная замена со стр2 до конца

cat *.log | sed -r -n '/Создать/p' |less

-i работа inplace прям с файлом который мы ему предоставляем
Это нужно потому что нельзя написать sed 's/1/Q/' < file > file
т.к. файл сначала откроется на запись и при чтении он уже станет нулевой длины

sed -i 's/2/Q/' file
sed -i.back 's/2/Q/' file





















